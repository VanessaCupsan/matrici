<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="richTextBox2.Text" xml:space="preserve">
    <value>   

          MATRICILE joacă un rol important în viața de zi cu zi, chiar dacă mulți dintre noi nu suntem conștienți de acest lucru. Utilizând structura matricilor au fost concepute diverse siteme și tehnologii fără de care, în vremea noastră, multe dintre activitățile zilnice nu s-ar putea desfășura.

                MATRICILE STAU LA BAZA CREĂRII TUTUROR JOCURILOR CE AU LA BAZĂ ALGORITMI DE PERMUTĂRI, ARANJAMENTE ETC.:

                    Realizarea jocurilor de șah pe calculator- cea mai simplă metodă de reprezentare a tablei de șah     este o matrice de dimensiuni 8*8. În această reprezentare fiecare element al matricei este un pătrat al tablei de     joc și valoarea elementului este tipul piesei din pătratul respectiv.
                    Cubul lui Rubik- Acesta constă dintr-o matrice 3*3*3 de cuburi mai mici. Fețele cuburilor mici sunt colorate diferit, iar fețele cubului mare sunt fixate pe pivoți , astfel încât să se poată roti în diferite direcții. Obiectivul jocului este de a da fiecarei fețe a cubului mare o singură culoare. 

                MATRICILE STAU LA BAZA CREĂRII FOTOGRAFIILOR

                    Pentru a putea fi prelucrate (cu calculatorul), imaginile grafice trebuie mai întâi să fie digitalizate, adică împărțite în multe elemente mici (de exemplu ca o tablă de șah, sau și după alte sisteme), și anume atât de mărunt, încât fiecare element să aibă o singură culoare, sau măcar o singură culoare clar dominantă. Atunci fiecare astfel de element, numit pixel, posedă trei atribute care se pot exprima digital (numeric): culoare, opacitate (transparență) și poziție în matricea în care se divide imaginea.
</value>
  </data>
  <data name="richTextBox1.Text" xml:space="preserve">
    <value>                                                                                    DEFINIȚIE

    O matrice este o formă de organizare tabelară a unor elemente care au același tip, acestea putând fi identificate printr-un nume urmat (între paranteze drepte) de poziția lor în cadrul tabloului bidimensional. Identificarea poziției se realizează prin specificarea liniei și coloanei pe care se află elementul respectiv.

                                                      DECLARAREA TABLOURILOR BIDIMENSIONALE

    Declararea tablourilor bidimensionale (matrice) se face în C/C++ similar cu a tablourilor unidimensionale, dar trebuie precizate două dimensiuni fizice, maximale: numărul maxim de linii și numărul maxim de coloane ale matricei:

    tipDeBază denumire[NumarLinii][NumarColoane];

    de exemplu:
         int M[5][6];         - declară o matrice de 5 de linii și 6 coloane conținând numere întregi
         float F[10][15];   - declară o matrice de 10 linii și 15 coloane conținând numere reale
         char C[20][50];  - declară o matrice de 20 de linii și 50 de coloane conținând caractere alfanumerice
    Primul exemplu ni-l putem imagina astfel:












Matricea are:
5 linii, indexate (numerotate) de la 0 la 4 –sunt evidențiate liniile cu indici 1 și 3;
6 coloane, indexate de la 0 la 5 – sunt evidențiate coloanele cu indici 0 și 4;
</value>
  </data>
  <data name="richTextBox3.Text" xml:space="preserve">
    <value>                                                              CÂTĂ MEMORIE OCUPĂ O MATRICE?

    Majoritatea problemelor de informatică , fie ele de la concursuri, olimpiade sau de pe site-uri de învățare au precizate o serie de restricții , printre care limita maximă de memorie care poate fi folosită. Cum se poate calcula această limită maximă de memorie ? 

    Există doi factori care pot influența răspunsul :
        -tipul elementelor matricei;
        -dimensiunile precizate la declarare;
    Fiecare tip de dată ocupă o anumită memorie:




















    
    EXEMPLU :
        int A[20][30];
    -matricea A are 20 x 30=600 de elemente de tip int. O dată de tip int ocupă 4 octeți, deci matricea A va ocupa 20 x 30 x 4=2400 de octeți ( B ).</value>
  </data>
  <data name="label1.Text" xml:space="preserve">
    <value>    Pentru a vă facilita înțelegerea tablourilor bidimensionale, am pregătit un instrument cu ajutorul căruia puteți crea matrici de dimensiuni variante. Veți introduce numărul de linii și de coloane în casetele de mai jos și astfel se va crea o matrice proprie. 
    De asemenea, puteți completa cu numere căsuțele libere din tabel.</value>
  </data>
</root>