<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="richTextBox2.Text" xml:space="preserve">
    <value>    
    Referirea elementelor se face prin intermediul operatorului C++ de indexare [], la fel ca în cazul vectorilor, dar trebuie precizați doi indici – cel de linie și cel de coloană. Astfel, A[2][4] reprezintă elementul matricei aflat pe linia 2 și pe coloana 4 – la intersecția dintre linia 2 și coloana 4. Astfel primul indice al unui element este cel de linie, iar al doilea indice este cel de coloană.
    EXEMPLU:








    




    


    OBSERVAȚIE : Cade în sarcina programatorului să se asigure că valorile indicilor folosiți în expresiile de indexare fac parte din intervalul corect, conform declarării tabloului. Dacă valorile indicilor nu sunt corecte, comportamentul programului este impredictibil: rezultatele obținute vor fi eronate sau se vor produce erori la execuția programului. Aceste erori la execuție sunt de regulă semnalate cu mesajul Killed by signal 11 sau Caught fatal signal 11.

    De exemplu, pentru matricea de mai sus, expresiile A[-1][7], A[2][20], A[7][7], A[7][30] sunt greșite. Rezultatele (efectele) sunt impredictibile.

</value>
  </data>
  <data name="richTextBox1.Text" xml:space="preserve">
    <value>    
Ne putem gândi la un tablou bidimensional în două moduri:
        -A este o matrice;
        -A are linii și coloane. A[2][5] este elementul aflat pe linia 1 și coloana 9;

    sau:
        -A este un vector; elementele lui A sunt vectori;
        -A[2] este un vector – reprezintă o linie din matricea A;
        -A[2][5] este un element al vectorului A[2], de tip int

    De asemenea, atunci când ne gândim la o matrice ca la un vector, nu vor mai exista doi indici ai unui element( cel de linie și cel de coloană) , ci unul singur, ca la un tablou unidimensional.
Indicii elementelor vor arăta astfel :

    Fie matricea A[3][5] cu elementele de aceeași valoare ca indicii lor;









    Pentru a calcula poziția, alcătuită din două coordonate, a unui element, se va împărți indicele elementului la numărul de coloane din matrice. Astfel, câtul va reprezenta indicele liniei, iar restul indicele coloanei.

    EXEMPLU:

    Luăm elementul cu indicele 7 din matricea A. Îl împărțim la 5 , întrucât există 5 coloane în tabloul bidimensional dat, și calculăm câtul și restul.
                7 : 5 = 1, rest 2
     =&gt; Elementul cu indicele 7 se află pe linia 1 și coloana 2.
</value>
  </data>
  <data name="richTextBox4.Text" xml:space="preserve">
    <value>
    Fiecare element al unei matrice are cel puțin 2 vecini( prin vecini înțelegem elementele care se află cu o poziție mai sus, mai jos, la stânga sau la dreapta ). În funcție de numărul acestora ne putem da seama dacă elementul respectiv se află pe marginea sau în interiorul tabloului bidimensional.

    Astfel, dacă elementul are 2 sau 3 vecini, atunci el se afla pe margine, iar daca are 4 vecini se află în interior.
    EXEMPLU :
    -fie matricea A[4][6] ;
</value>
  </data>
  <metadata name="$this.Locked" type="System.Boolean, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
</root>